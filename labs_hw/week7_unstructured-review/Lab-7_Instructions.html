<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Instructions</title>
    <style>
/* Lab Instructions Styling */
/* Optimized for markdown-to-HTML lab materials */

/* Mac's Customized CSS */

details.inline-image {
    color: #BE0000;
 }
 details[open].inline-image {
     font-weight: bold;
 }
 details[open].inline-image > p {
     border-left: 5px solid #BE0000;
     margin-left: 1em;
     padding-left: 1em;
 }
 .detail-image {
     max-height: 500px;
     max-width: 1000px;
     border: 1px solid #ccc;
     border-radius: 4px;
     box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
     margin: 10px 0;
 }

 .fixed-width {
     font-family: "Courier New", Courier, monospace;
     background-color: #f5f5f5;
     border: 1px solid #ccc;
     border-radius: 4px;
     /* padding: 2px 4px; */
 }

/* Claud's generated CSS */
/* Base Styles */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    line-height: 1.6;
    max-width: 1800px;
    margin: 0 auto;
    padding: 2rem;
    color: #333;
    background-color: #ebebeb;
}

/* Main Content Container */
article, main {
    background: white;
    padding: 2.5rem;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    line-height: 1.3;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #1a1a1a;
}

h1 {
    font-size: 2.25rem;
    border-bottom: 3px solid #0066cc;
    padding-bottom: 0.5rem;
    margin-top: 0;
    color: #0066cc;
}

h2 {
    font-size: 1.75rem;
    border-bottom: 2px solid #e0e0e0;
    padding-bottom: 0.4rem;
    margin-top: 2.5rem;
}

h3 {
    font-size: 1.4rem;
    color: #2c5282;
}

h4 {
    font-size: 1.15rem;
    color: #2d3748;
}

/* Section Delineation */
h2::before {
    content: '';
    display: block;
    height: 1px;
    background: linear-gradient(to right, transparent, #0066cc, transparent);
    margin-bottom: 1rem;
}

/* Add visual breaks between major sections */
h2 {
    margin-top: 3rem;
    padding-top: 2rem;
}

/* Numbered sections (e.g., "1. Assignment", "2. Data") */
h2:first-of-type {
    margin-top: 1.5rem;
    padding-top: 0;
}

/* Subsection styling */
h3 {
    margin-top: 1.8rem;
    padding-left: 0.5rem;
    border-left: 4px solid #0066cc;
}

h4 {
    margin-top: 1.3rem;
    padding-left: 0.75rem;
    border-left: 3px solid #cbd5e0;
}

/* Paragraphs and Lists */
p {
    margin: 1rem 0;
    text-align: justify;
}

ul, ol {
    margin: 1rem 0;
    padding-left: 2rem;
}

li {
    margin: 0.5rem 0;
}

li > p {
    margin: 0.25rem 0;
}

/* Nested lists */
ul ul, ol ul, ul ol, ol ol {
    margin: 0.25rem 0;
}

/* Code Blocks and Inline Code */
code {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    font-size: 0.9em;
    background-color: #f5f5f5;
    padding: 0.2em 0.4em;
    border-radius: 3px;
    border: 1px solid #e0e0e0;
}

pre {
    background-color: #2d2d2d;
    color: #f8f8f2;
    padding: 1.25rem;
    border-radius: 6px;
    overflow-x: auto;
    margin: 1.5rem 0;
    border-left: 4px solid #0066cc;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

pre code {
    background-color: transparent;
    border: none;
    padding: 0;
    color: inherit;
    font-size: 0.95em;
    line-height: 1.5;
}

/* Code block language labels */
pre[class*="language-"]::before {
    content: attr(class);
    display: block;
    text-align: right;
    font-size: 0.75rem;
    color: #888;
    margin-bottom: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

/* Tables */
table {
    border-collapse: collapse;
    margin: 1.5rem 0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Credit https://stackoverflow.com/questions/68779936/booktabs-like-tables-for-markdown */
/* Make horizontal lines connect through column boundaries */
table td, table th {
    border: 1px solid #aaaaaaaa;
}

table > :is(thead, tbody) > tr > :is(th, td) {
    padding: 3px;
    text-align: left;
}
table > thead > tr > :is(th, td) {
    border-top: 2px solid; /* Top thick line */
    border-bottom: 1px solid; /* Below head thin line */
}
table > tbody > tr:last-child > :is(th, td) {
    border-bottom: 2px solid; /* Bottom thick line */
}

tr:nth-child(even) {
    background-color: hsla(0, 0%, 0%, 0.1);
}

/* Blockquotes and Notes */
blockquote {
    border-left: 4px solid #0066cc;
    padding: 0.75rem 1.25rem;
    margin: 1.5rem 0;
    background-color: #f0f4f8;
    border-radius: 4px;
    color: #2c5282;
}

blockquote p:first-child {
    margin-top: 0;
}

blockquote p:last-child {
    margin-bottom: 0;
}

/* Special callout boxes */
.note, .warning, .tip {
    padding: 1rem 1.25rem;
    margin: 1.5rem;
    border-radius: 6px;
    border-left: 5px solid;
    border-right: 5px solid;
}

.note {
    background-color: #e3f2fd;
    border-color: #2196f3;
}

.warning {
    background-color: #fff3e0;
    border-color: #ff9800;
}

.tip {
    background-color: #e8f5e9;
    border-color: #4caf50;
}

/* Emphasis for key terms */
em {
    font-style: italic;
    color: #2c5282;
}

strong {
    font-weight: 600;
    color: #1a202c;
}

.small, .smol {
    font-size: 0.75rem;
    color: #555;
}

/* Links */
a {
    color: #0066cc;
    text-decoration: none;
    border-bottom: 1px solid transparent;
    transition: border-bottom-color 0.2s;
}

a:hover {
    border-bottom-color: #0066cc;
}

/* Task/Exercise sections */
h3[id*="exercise"]::before,
h3[id*="task"]::before {
    content: 'üìù ';
    margin-right: 0.5rem;
}

/* Questions sections */
h4[id*="question"]::before {
    content: '‚ùì ';
    margin-right: 0.5rem;
}

/* Technical guidance sections */
h3[id*="implementation"]::before,
h3[id*="guidance"]::before {
    content: 'üîß ';
    margin-right: 0.5rem;
}

/* Horizontal Rules */
hr {
    border: none;
    height: 2px;
    background: linear-gradient(to right, transparent, #0066cc, transparent);
    margin: 2.5rem 0;
}

/* TOC Styling */
nav, .toc {
    background-color: #f8f9fa;
    padding: 1.25rem;
    border-radius: 6px;
    margin: 1.5rem 0;
    border: 1px solid #e0e0e0;
}

nav ul, .toc ul {
    list-style: none;
    padding-left: 1rem;
}

nav li, .toc li {
    margin: 0.4rem 0;
}

/* Submission/Assignment boxes */
section[id*="assignment"] {
    background-color: #fff8e1;
    padding: 1.5rem;
    border-radius: 6px;
    border-left: 5px solid #ffa726;
    margin: 1.5rem 0;
}

/* Learning objectives header */
h3[id*="learning"]::before , h3[id*="objective"]::before {
    content: " üí° ";
    margin-right: 0.5rem;
}

/* Learning objectives lists */
h3[id*="learning"] ~ ul:first-of-type,
h3[id*="objective"] ~ ul:first-of-type {
    background-color: #f0f4f8;
    padding: 1rem 1.5rem 1rem 3rem;
    border-radius: 6px;
    list-style-type: "üí°";
}

/* Rubric and grading header */
h3[id*="rubric"]::before , h3[id*="grading"]::before {
    content: " üìù ";
    margin-right: 0.5rem;
}
/* Excel header */
h3[id*="excel"]::before {
    content: " ùÑú ";
    margin-right: 0.5rem;
}
/* Python header */
h3[id*="python"]::before {
    content: " üêç ";
    margin-right: 0.5rem;
}

/* Hidden Screenshot */
.inline-image > summary::before {
    content: " üñºÔ∏è ";
    margin-right: 0.5rem;
}


/* Formulas and math expressions */
.math, .formula {
    font-family: 'Times New Roman', Times, serif;
    font-style: italic;
    background-color: #f9f9f9;
    padding: 0.5rem 1rem;
    margin: 1rem 0;
    border-radius: 4px;
    text-align: center;
    border: 1px solid #e0e0e0;
}

/* Variable names in text */
var, .variable {
    font-family: 'Monaco', 'Menlo', monospace;
    font-style: normal;
    background-color: #f5f5f5;
    padding: 0.1em 0.3em;
    border-radius: 2px;
    font-weight: 500;
}

/* Print styles */
@media print {
    body {
        background-color: white;
        padding: 0;
    }

    article, main {
        box-shadow: none;
        padding: 0;
    }

    pre {
        border: 1px solid #ccc;
        page-break-inside: avoid;
    }

    h2, h3, h4 {
        page-break-after: avoid;
    }
}

/* Responsive design */
@media (max-width: 768px) {
    body {
        padding: 1rem;
        font-size: 0.95rem;
    }

    article, main {
        padding: 1.5rem;
    }

    h1 {
        font-size: 1.75rem;
    }

    h2 {
        font-size: 1.4rem;
    }

    h3 {
        font-size: 1.2rem;
    }

    pre {
        padding: 1rem;
        font-size: 0.85rem;
    }

    table {
        font-size: 0.9rem;
    }
}

</style><style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #dadada; }
.highlight .c { color: #3D7B7B; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #F00 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666 } /* Operator */
.highlight .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #9C6500 } /* Comment.Preproc */
.highlight .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.highlight .gr { color: #E40000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #008400 } /* Generic.Inserted */
.highlight .go { color: #717171 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #04D } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #687822 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #00F; font-weight: bold } /* Name.Class */
.highlight .no { color: #800 } /* Name.Constant */
.highlight .nd { color: #A2F } /* Name.Decorator */
.highlight .ni { color: #717171; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #00F } /* Name.Function */
.highlight .nl { color: #767600 } /* Name.Label */
.highlight .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.highlight .w { color: #BBB } /* Text.Whitespace */
.highlight .mb { color: #666 } /* Literal.Number.Bin */
.highlight .mf { color: #666 } /* Literal.Number.Float */
.highlight .mh { color: #666 } /* Literal.Number.Hex */
.highlight .mi { color: #666 } /* Literal.Number.Integer */
.highlight .mo { color: #666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #A45A77 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #00F } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
</head>
<body>
    <h1 class="ada-h1" id="lab-7-unstructured-data-processing">Lab 7: Unstructured Data Processing</h1>
<p>In this lab, you will work with a dataset that simulates real-world messy data. The dataset contains standard structured columns (ID, Date, Customer_ID, UPC, Number_Items, Total) but also a "Notes" column that is a dump of unstructured text containing critical information like Invoice Numbers, Account Representative Names, Follow-up Dates, and general notes.</p>
<p>Your goal is to parse this <code class="fixed-width">Notes</code> column into structured data, using regular expressions (RegEx).
This lab offers instructions for three different approaches: Excel (RegEx in Office Scripts), Google Sheets (<code class="fixed-width">RegExExtract</code> Formula), and Python (RegEx is a built in library <code class="fixed-width">re</code>).</p>
<div class="toc">
<ul>
<li><a href="#lab-7-unstructured-data-processing">Lab 7: Unstructured Data Processing</a><ul>
<li><a href="#1-assignment">1. Assignment</a><ul>
<li><a href="#11-learning-objectives">1.1. Learning Objectives</a></li>
</ul>
</li>
<li><a href="#2-data">2. Data</a></li>
<li><a href="#3-how-to-steps">3. How-to Steps</a><ul>
<li><a href="#31-option-a-excel-office-scripts">3.1. Option A: Excel (Office Scripts)</a></li>
<li><a href="#32-option-b-google-sheets-regex">3.2. Option B: Google Sheets (REGEX)</a></li>
<li><a href="#33-option-c-python-re">3.3. Option C: Python (re)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 class="ada-h2" id="1-assignment">1. Assignment</h2>
<p>To complete this lab, submit the following on Canvas:</p>
<ol>
<li>Regular Expressions used for each column:<ul>
<li>Invoice</li>
<li>Account Rep Name</li>
<li>Follow-up Date</li>
<li>General Notes</li>
</ul>
</li>
<li><em>Excel/CSV File</em>: A cleaned version of the dataset where the <code class="fixed-width">Notes</code> column has been split into <code class="fixed-width">Invoice_Number</code>, <code class="fixed-width">Contact_Name</code>, <code class="fixed-width">Follow_Up_Date</code>, and <code class="fixed-width">Clean_Notes</code>.</li>
</ol>
<h3 class="ada-h3" id="11-learning-objectives">1.1. Learning Objectives</h3>
<p>By the end of this lab, you will be able to:</p>
<ul>
<li>Identify unstructured text patterns suitable for regex extraction.</li>
<li>Use tools to extract usable information from unstructured text, including:<ul>
<li>Excel Office Scripts (TypeScript) for, among other automation, regex-based text parsing</li>
<li>Google Sheets <code class="fixed-width">REGEXEXTRACT</code> for quick text extraction</li>
<li>Python's <code class="fixed-width">re</code> module for robust pattern matching and extracting</li>
</ul>
</li>
</ul>
<h2 class="ada-h2" id="2-data">2. Data</h2>
<p>The dataset <code class="fixed-width">lab7_data.xlsx</code> is provided on Canvas</p>
<ul>
<li><em>Structured Columns</em>: <code class="fixed-width">id</code>, <code class="fixed-width">date</code>, <code class="fixed-width">customer_id</code>, <code class="fixed-width">upc</code>, <code class="fixed-width">number_items</code>, <code class="fixed-width">total</code>.</li>
<li><em>Unstructured Column</em>: <code class="fixed-width">notes</code>. This column typically looks like:
    <div class="highlight"><pre><span></span><code>Inv #: INV2022-68987
Rep: Gimli Gloinsson
Follow-up By: 2022-07-07
Notes: Inspected the Dwarven axe heads delivery. Minor chipping on three units (Lot AX-77). Initiated RMA process. Billing adjustment pending.
</code></pre></div></li>
</ul>
<p>In the <code class="fixed-width">notes</code> column, there are inconsistencies, typos, and missing fields (a very common scenario in real-world data):</p>
<ul>
<li>All fields have <code class="fixed-width">[title]:</code> as a format, meaning you could brute-force search for those, or use regular expressions that look for the general pattern with a colon to end it.</li>
<li><strong>Invoice #</strong>: Can have the title <code class="fixed-width">Invoice #</code>, <code class="fixed-width">Invoice#</code>, <code class="fixed-width">Inv #</code>, or <code class="fixed-width">Inv#</code><ul>
<li>Logic: <code class="fixed-width">Inv____#:</code> --&gt; end of line</li>
</ul>
</li>
<li><strong>Account rep</strong>: Can have the title <code class="fixed-width">Rep</code>, <code class="fixed-width">Representative</code>, <code class="fixed-width">Account Rep</code>, <code class="fixed-width">ARep</code><ul>
<li>Logic: <code class="fixed-width">(A____)?Rep____:</code> --&gt; end of line</li>
</ul>
</li>
<li><strong>Follow up date</strong>: <em>Can be missing!</em> Can have the title <code class="fixed-width">Follow-up Date</code>, <code class="fixed-width">Follow up Date</code>, <code class="fixed-width">Follow-up On</code>, <code class="fixed-width">Follow-up By</code>, <code class="fixed-width">Follow-up</code><ul>
<li>Logic <em>if found</em>: <code class="fixed-width">Follow____:</code> --&gt; end of line</li>
</ul>
</li>
<li><strong>Notes</strong>: Can have newlines in it, meaning the notes spill onto the next line. Can have the title <code class="fixed-width">Note</code> or <code class="fixed-width">Notes</code><ul>
<li>Logic: <code class="fixed-width">Notes?:</code> --&gt; end</li>
</ul>
</li>
</ul>
<h2 class="ada-h2" id="3-how-to-steps">3. How-to Steps</h2>
<h3 class="ada-h3" id="31-option-a-excel-office-scripts">3.1. Option A: Excel (Office Scripts)</h3>
<p>Modern Excel on the web (and desktop) supports <strong>Office Scripts</strong>, which uses TypeScript to automate tasks. 
Alternatively, you could use Python in Excel Online, but we won't cover that here.</p>
<p>The basic idea is to write a script that iterates through the <code class="fixed-width">notes</code> column, applies regex patterns to extract the relevant information, and writes it back to new columns.</p>
<ol>
<li>Open your Excel file</li>
<li>Go to the <strong>Automate</strong> tab &gt; <strong>New Script</strong></li>
<li>Write a script that iterates through the sheet, adding the 4 new columns by using regular expressions to extract the data from the <code class="fixed-width">notes</code> column<ol>
<li>Create 4 new headers to fill with data: <code class="fixed-width">Invoice_Number</code>, <code class="fixed-width">Contact_Name</code>, <code class="fixed-width">Follow_Up_Date</code>, and <code class="fixed-width">Clean_Notes</code>.</li>
<li>For each row, look at the <code class="fixed-width">notes</code> column.</li>
<li>Use regex to extract data, for example: <code class="fixed-width">const regex = /Invoice: (.*)/;</code></li>
<li>Write the extracted values into new columns</li>
</ol>
</li>
</ol>
<p>This is where asking an LLM for help with Office Scripts can be very useful, as the syntax can be a bit tricky if you're not used to it.</p>
<p>Here's the prompt I asked Claude:</p>
<div class="highlight"><pre><span></span><code>I have this spreadsheet, and want to write an officescript regular expression parser.
I want to create 4 new columns (<span class="sb">`Invoice_Number`</span>, <span class="sb">`Contact_Name`</span>, <span class="sb">`Follow_Up_Date`</span>,
 and <span class="sb">`Clean_Notes`</span>), extracting the data from the <span class="sb">`notes`</span> field with regular 
 expressions. Please write the officescript macro to do this.
</code></pre></div>
<p>And he provided this sample code to get you started:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">main</span><span class="p">(</span><span class="nx">workbook</span><span class="o">:</span><span class="w"> </span><span class="kt">ExcelScript.Workbook</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">sheet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">workbook</span><span class="p">.</span><span class="nx">getActiveWorksheet</span><span class="p">();</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">usedRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">sheet</span><span class="p">.</span><span class="nx">getUsedRange</span><span class="p">();</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">usedRange</span><span class="p">.</span><span class="nx">getValues</span><span class="p">();</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">headers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kt">string</span><span class="p">[];</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">notesCol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">headers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;notes&#39;</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">notesCol</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;&#39;notes&#39; column not found&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">newHeaders</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;Invoice_Number&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Contact_Name&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Follow_Up_Date&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Clean_Notes&#39;</span><span class="p">];</span>
<span class="w">  </span><span class="nx">newHeaders</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">header</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sheet</span><span class="p">.</span><span class="nx">getCell</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">headers</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">i</span><span class="p">).</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">header</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="c1">// Mac wrote the commented out ones, Claude the ones that aren&#39;t. Mine are a bit more flexible.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">invoicePattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sr">/(?:Invoice\s*#|Inv\s*#?):\s*([^\n]+)/i</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// const invoicePattern = /(?:Inv\w*\s*#?):\s*([^\n]+)/i;</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">contactPattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sr">/(?:Representative|Account\s+Rep|ARep|Rep):\s*([^\n]+)/i</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// const contactPattern = /(?:A[count ]*)?Rep(?:[^:]*):\s*([^\n]+)/i;</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">followUpPattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sr">/Follow[-\s]*up(?:\s+(?:On|Date))?:\s*([^\n]+)/i</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// const followUpPattern = /Follow(?:[^:]*):\s*([^\n]+)/i;</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">notesPattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sr">/Notes?:\s*(.+)/is</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Dropping anything in parentheses in the contact:</span>
<span class="w">  </span><span class="c1">// const contactPattern = /(?:A[count ]*)?Rep(?:[^:]*):\s*([^\n(]+)/i;</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">row</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">notes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">notesCol</span><span class="p">]</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">;</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">invoiceMatch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">notes</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">invoicePattern</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">contactMatch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">notes</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">contactPattern</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">followUpMatch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">notes</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">followUpPattern</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">notesMatch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">notes</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">notesPattern</span><span class="p">);</span>

<span class="w">    </span><span class="nx">sheet</span><span class="p">.</span><span class="nx">getCell</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">headers</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">invoiceMatch</span><span class="o">?</span><span class="p">.[</span><span class="mf">1</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="nx">trim</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">sheet</span><span class="p">.</span><span class="nx">getCell</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">headers</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">).</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">contactMatch</span><span class="o">?</span><span class="p">.[</span><span class="mf">1</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="nx">trim</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">sheet</span><span class="p">.</span><span class="nx">getCell</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">headers</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="p">).</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">followUpMatch</span><span class="o">?</span><span class="p">.[</span><span class="mf">1</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="nx">trim</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">sheet</span><span class="p">.</span><span class="nx">getCell</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">headers</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">3</span><span class="p">).</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">notesMatch</span><span class="o">?</span><span class="p">.[</span><span class="mf">1</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="nx">trim</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 class="ada-h3" id="32-option-b-google-sheets-regex">3.2. Option B: Google Sheets (REGEX)</h3>
<p>Google Sheets has powerful built-in regex functions: <code class="fixed-width">REGEXMATCH</code>, <code class="fixed-width">REGEXEXTRACT</code>, and <code class="fixed-width">REGEXREPLACE</code>.</p>
<ol>
<li>Import the Excel file into Google Sheets.</li>
<li>Create a new column <code class="fixed-width">Invoice_Number</code>.</li>
<li>Use <code class="fixed-width">=REGEXEXTRACT($G2, "(?:Inv\w*\s*#?):\s*([^\n]+)")</code> to pull out the Invoice.</li>
<li>Repeat for Contact and Date (see above office script for working regular expressions)</li>
<li>Download the cleaned sheet as CSV for upload to Canvas: <code class="fixed-width">File &gt; Download &gt; Comma-separated values (.csv)</code></li>
</ol>
<h3 class="ada-h3" id="33-option-c-python-re">3.3. Option C: Python (<code class="fixed-width">re</code>)</h3>
<p>Python is great for customized, flexible, and powerful text processing.</p>
<ol>
<li>Load the data using <code class="fixed-width">pandas</code>.</li>
<li>Use the built in pandas <code class="fixed-width">Series.str.extract</code> method with regular expressions to get the data:
    <div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="s2">&quot;lab7_data.xlsx&quot;</span><span class="p">)</span>

<span class="n">df</span><span class="p">[</span><span class="s1">&#39;Invoice_Number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;notes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?:Inv\w*\s*#?):\s*([^\n]+)&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
<span class="c1"># Continue with the other three columns using the same approach, just changing the regular expression pattern.</span>
</code></pre></div></li>
<li>Repeat for Contact and Date (see above office script for working regular expressions)</li>
<li>Save the cleaned dataframe to Excel for upload: <code class="fixed-width">df.to_excel("lab7_data_cleaned.xlsx", index=False)</code></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="c1"># If you&#39;re curious, re is the regex module. You can do things like:</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?:Inv\w*\s*#?):\s*([^\n]+)&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
<span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;Inv #: INV2022-68987&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># This would return &#39;INV2022-68987&#39;</span>
<span class="n">pattern</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;INVOICE#: \1&quot;</span><span class="p">,</span> <span class="s2">&quot;Inv #: INV2022-68987&quot;</span><span class="p">)</span>  <span class="c1"># This would return &#39;INVOICE#: INV2022-68987&#39;.</span>
<span class="c1"># That \1 is a backreference to the first group in the pattern, which is the actual invoice number. Super cool.</span>
</code></pre></div>
</body>
</html>
